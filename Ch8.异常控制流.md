> 本章的内容真是大开眼界！异常是软硬件结合的非常有用的系统机制，比如系统调用。另外fork、execve等系统函数的使用，神奇的多进程模式。



##### 问题

* 编程语言中的异常处理机制，和这里的异常控制流是怎样的关联？ 



#### 摘记

* 改变程序状态的控制流机制：
  * 分支和跳转；
  * 函数调用和返回；

* 而系统状态的控制，如：数据从网络到达；除0；键盘的中断等等；超出了程序的控制流。需要异常控制机制。

* 异常控制机制，存在于计算机系统的所有层面：
  * 低级别机制：硬件和操作系统的组合实现；
  * 高级别的机制：进程的上下文切换；信号；非本地跳转；

##### 异常

* 异常是将控制权转移到操作系统内核（来响应某些事件）。（内核是操作系统的内存驻留部分）。内核进行异常处理，会有3种情况：返回并重新执行当前指令；返回到下一条指令；中止。
* 异常由硬件和软件共同实现。程序计数器（%rip寄存器）的更改由硬件完成，异常代码则由内核设定。
* 同步、异步异常。
  * 异步异常是由处理器外部状态变化引起的，称为中断。通过在处理器上设置引脚。通常在后台运行，不影响程序执行。比如计时器中断，定时运行，以便内核获取控制权。以及IO设备的中断。
  * 同步异常。有三类。
    * 一种是陷阱：由程序故意引起的异常，如系统调用（程序没有直接访问内核服务的权限，不能直接调用内核函数和内核数据，因为该内存受保护不可用，而系统调用就是内核开放的接口，看起来像函数调用，但却是控制器转移到内核）。
    * 故障。故障是无意的，有些可恢复，如页缺失；有些不可恢复，如访问未分配的内存。
    * 中止。不可恢复。比如机器存在问题。。。

##### 进程

* 正在运行的程序的实例。提供了2个核心抽象（文中用”幻觉“一词）：
  * 逻辑控制流上，每个程序似乎独占CPU。（内核的上下文切换机制）
  * 独立的地址空间（代码、数据、堆栈、heap）。（虚拟内存机制）

* 上下文：进程的地址空间和寄存器值 
* 并发：两个进程的逻辑控制流在实际上重叠。即使只有一个cpu核。
* fork()函数的神奇之处：同时返回到父进程和子进程，前者返回值是子进程id，后者是0（表示成功）；
* wait(int * child_status)：挂起当前进程，直到其中一个子进程中止。
* execve：在当前进程中 加载和运行程序；
* 通过fork + execve的组合 来实现创建新进程并执行，而不是一个调用完成，灵活且强大。（比如并发场景，可能只想fork出一样的子进程）。
  * 子进程的执行时机不受控制。

##### 信号

* 软件层面的实现，从内核发送到用户进程；
* 用户进程可以捕获信号，进行处理（区别于异常处理，其是内核级别的）
* 信号处理函数（signal handler）是个独立的逻辑流程（不是进程）和主程序是并发跑的。（并发指的是时间上重叠的逻辑流）=> 神奇！
* volatile 属性可以防止编译器把它的值放入寄存器，始终通过内存读写。
* 信号程序好写，不过很不安全。很多tricky。